# **Desafio PrÃ¡tico â€“ Analista DevOps Pleno**

&nbsp;

# Objetivo

Criar duas aplicaÃ§Ãµes com rotas especÃ­ficas, implementar cache com tempos de expiraÃ§Ã£o diferentes, automatizar a infraestrutura, criar um diagrama arquitetural e sugerir melhorias, com o cÃ³digo e configuraÃ§Ãµes armazenados em um repositÃ³rio para avaliaÃ§Ã£o.

&nbsp;

# Tarefas

1.  **Criar duas aplicaÃ§Ãµes**
    1.  Utilize linguagens diferentes.
    2.  Cada aplicaÃ§Ã£o deve ter duas rotas:
        1.  Uma retornando um texto fixo.
        2.  Outra retornando o horÃ¡rio atual do servidor.
2.  **Adicionar uma camada de cache,** as respostas das aplicaÃ§Ãµes devem ser cacheadas por diferentes tempos de expiraÃ§Ã£o.
    1.  A primeira aplicaÃ§Ã£o deve ter um cache de **10 segundos**.
    2.  A segunda aplicaÃ§Ã£o deve ter um cache de **1 minuto**.
3.  **Facilitar a execuÃ§Ã£o**
    1.  A infraestrutura deve ser fÃ¡cil de iniciar e rodar com o menor nÃºmero de comandos possÃ­vel.
4.  **Implementar observabilidade se possÃ­vel**
5.  **Desenhar e analisar a infraestrutura**
    1.  Criar um diagrama representando a arquitetura.
6.  Identificar e sugerir pontos de melhoria.
7.  AtualizaÃ§Ãµes
    1.  No desenho mostre como seriam fluxo de atualizaÃ§Ã£o de cada componente da infra e do cÃ³digo.
    2.  Identificar e sugerir pontos de melhoria.

**Entrega esperada**

- CÃ³digo-fonte das aplicaÃ§Ãµes e sua respectiva infra
- ConfiguraÃ§Ã£o da camada de cache.
- Infraestrutura automatizada para fÃ¡cil execuÃ§Ã£o.
- Diagrama da infraestrutura com anÃ¡lise e sugestÃµes de melhoria.
- Sempre bom manter as boas prÃ¡ticas e organizaÃ§Ã£o no Git

**Como entregar**

- Todo o conteÃºdo gerado no teste deve ser armazenado em um repositÃ³rio de uma ferramenta de versionamento de cÃ³digo, esse repositÃ³rio deve estar acessÃ­vel para avaliaÃ§Ã£o.

&nbsp;

# Proposta de soluÃ§Ã£o:

**AplicaÃ§Ãµes:**

&nbsp; Â  Â  Â  1 - **Healthcheck** em **Python + Flask**, retornando um texto fixo ("Servidor OK!").  
Â  Â  Â  Â  2 - HorÃ¡rio do servidor em **JavaScript + Node.js****,** retornando o horÃ¡rio local.

**Infraestrutura:**

&nbsp; Â  Â  Â  Servidor na EC2 com **Terraform** instalado para:

&nbsp; Â  Â  Â  Â  Â  Â  Â  1 - Implantar infraestrutura de cluster no **Kubernetes**;

**Cache:**

&nbsp; Â  Â  Â  Ainda em construÃ§Ã£o ğŸš§

**Observabilidade**:

&nbsp; Â  Â  Â  1 - ImplementaÃ§Ã£o do Prometheus e Grafana para coletar mÃ©tricas do cluster e da aplicaÃ§Ã£o.  
Â  Â  Â  Â  2 - DefiniÃ§Ã£o de alerta para monitorar o consumo de CPU e memÃ³ria da aplicaÃ§Ã£o.  
<br/>**Desenho da infraestrutura**

&nbsp; Â  Â  Â  Ainda em construÃ§Ã£o **ğŸš§**

**PrÃ³ximos passos**

&nbsp; Â  Â  Â  **Melhoria no mostrador de horÃ¡rio do servidor:**

&nbsp; Â  Â  Â  Â Â Â Â Â Â Â Â - Ajustar o cache para que atualize com uma frequÃªncia maior, ex: de 5 em 5 segundos

&nbsp; Â  Â  Â  Â Â Â Â Â Â Â Â - Ou atÃ© mesmo atualizar as horas dinamicamente.

&nbsp;

# PrÃ¡tica

&nbsp;

### Passo 1: Desenvolver as aplicaÃ§Ãµes e rodar localmente:

InstalaÃ§Ã£o das dependÃªncias da app de **healthcheck**:

1.  InstalaÃ§Ã£o do **flask**, que servirÃ¡ o app via web: `pip install Flask`
2.  Rodar o app localmente: `python3 healthcheck.py`

&nbsp;

InstalaÃ§Ã£o das dependÃªncias da app **mostrador de** horas:

1.  InstalaÃ§Ã£o do **nodejs** e **npm** atravÃ©s do comando `sudo apt install nodejs npm`
2.  InstalaÃ§Ã£o do **express**, que servirÃ¡ o app via web: `npm install express`
3.  Iniciar o projeto atravÃ©s do `npm init -y`
4.  Rodar o app: `node index.js`

&nbsp;

### Passo 2: Implantar as aplicaÃ§Ãµes usando Docker

1.  Instalar Docker na mÃ¡quina na EC2: `sudo apt-get install docker.io`
2.  Garantir as permissÃµes do Docker para o user atual: `sudo usermod -a -G docker $(whoami)`
3.  Aplicar as permissÃµes de grupo sem deslogar: `newgrp docker`

&nbsp;

**App healthcheck**

1.  Criar arquivo **dockerfile**
    
2.  Construir a imagem docker: `docker build -t app-healthcheck .`
    
3.  Executar a imagem criada: `docker run -d -p 5000:5000 app-healthcheck`.
    

&nbsp; Â  Â  Â  Primeira aplicaÃ§Ã£o rodando na porta 5000

&nbsp; Â  Â  Â  [imagem]

**App mostrador de hora**

1.  Criar arquivo **dockerfile**
2.  Construir a imagem docker: `docker build -t app-mostrador-horas .`
3.  Executar a imagem criada: `docker run -d -p 5001:5001 app-mostrador-horas`.

&nbsp; Â  Â  Â  Segunda aplicaÃ§Ã£o rodando na porta 5001.

&nbsp; Â  Â  Â  [imagem]

&nbsp;

### Passo 3: Orquestrar containers em um cluster do Kubernetes

&nbsp;

Antes do nginx:

[imagem]

&nbsp;
